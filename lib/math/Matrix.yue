import 'ffi'
import sqrt, sin, cos, tan from math

Matrix = ffi.typeof('Matrix')

MatrixMT = {
	identity: -> Matrix(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	)

	translate: (x, y, z) -> Matrix(
		1, 0, 0, x,
		0, 1, 0, y,
		0, 0, 1, z,
		0, 0, 0, 1
	)

	rotate: (axis, angle) ->
		{ :x, :y, :z } = axis
		lenSq = axis::lengthSquared!

		if lenSq ~= 1 and lengthSq ~= 0
			ilen = 1 / sqrt(lengthSq)
			x, y, z = x * ilen, y * ilen, z * ilen

		sn, cs = sin(angle), cos(angle)
		t = 1 - cs

		Matrix(
				x * x * t + cs, y * x * t + z * sn,	z * x * t - y * sn,	0,
			x * y * t - z * sn,     y * y * t + cs, z * y * t + x * sn, 0,
			x * z * t + y * sn, y * z * t - x * sn,	    z * z * t + cs, 0,
							 0,                  0,                  0, 1
		)

	rotateX: (angle) ->
		sn, cs = sin(angle), cos(angle)
		Matrix(
			1,  0,   0, 0,
			0, cs, -sn, 0,
			0, sn,  cs, 0,
			0,  0,   0, 1
		)

	rotateY: (angle) ->
		sn, cs = sin(angle), cos(angle)
		Matrix(
			 cs,  0, sn, 0,
			  0,  1,  0, 0,
			-sn,  0, cs, 0,
			  0,  0,  0, 1
		)

	rotateZ: (angle) ->
		sn, cs = sin(angle), cos(angle)
		Matrix(
			cs, -sn, 0, 0,
			sn,  cs, 0, 0,
			0,    0, 1, 0,
			0,    0, 0, 1
		)

	rotateXYZ: (angles) ->
		cx, sx = cos(-angles.x), sin(-angles.x)
		cy, sy = cos(-angles.y), sin(-angles.y)
		cz, sz = cos(-angles.z), sin(-angles.z)
		Matrix(
						   cz * cy,                sz * cy,     -sy, 0
			cz * sy * sx - sz * cx, sz * sy * sx + cz * cx, cy * sx, 0,
			cz * sy * cx + sz * sx, sz * sy * cx - cz * sx, cy * cx, 0,
								 0,                      0,       0, 1
		)

	rotateZYX: (angles) ->
		cx, sx = cos(angles.x), sin(angles.x)
		cy, sy = cos(angles.y), sin(angles.y)
		cz, sz = cos(angles.z), sin(angles.z)
		Matrix(
			cz * cy, cz * sy * sx - cx * sz, sz * sx + cz * cx * sy, 0,
			cy * sz, cz * cx + sz * sy * sx, cx * sz * sy - cz * sx, 0,
				-sy,                cy * sx,                cy * cx, 0,
				  0,                      0,                      0, 1
		)

	scale: (x, y, z) -> Matrix(
		x, 0, 0, 0,
		0, y, 0, 0,
		0, 0, z, 0,
		0, 0, 0, 1
	)

	frustum: (left, right, bottom, top, near, far) ->
		rl = right - left
		tb = top - bottom
		fn = far - near
		Matrix(
				(near * 2) / rl,                   0,                      0,  0,
							  0,     (near * 2) / tb,                      0,  0,
			(right + left) / rl, (top + bottom) / tb,     -(far + near) / fn, -1,
							  0,                   0, -(far * near * 2) / fn,  0
		)

	perspective: (fovy, aspect, near, far) ->
		top = near * tan(fovy * .5)
		right = top * aspect
		Matrix.frustum(-right, right, -top, top, near, far)

	ortho: (left, right, bottom, top, near, far) ->
		rl = right - left
		tb = top - bottom
		fn = far - near
		Matrix(
						   2 / rl,                     0,                   0, 0,
								0,                2 / tb,                   0, 0,
								0,                     0,             -2 / fn, 0,
			-(left + right ) / rl, -(top + bottom ) / tb, -(far + near ) / fn, 1
		)

	lookAt: (eye, target, up) ->
		vz = eye::subtract(target)::normalize!
		vx = up::crossProduct(vz)::normalize!
		vy = vz::crossProduct(vx)
		ex, ey, ez = vx::dotProduct(eye), vy::dotProduct(eye), vz::dotProduct(eye)
		Matrix(
			vx.x, vy.x, vz.x, 0,
			vx.y, vy.y, vz.y, 0,
			vx.z, vy.z, vz.z, 0,
			 -ex,  -ey,  -ez, 1
		)

	__tostring: => 'Matrix(%f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f)'::format(
		@m0, @m1, @m2, @m3,
		@m4, @m5, @m6, @m7,
		@m8, @m9, @m10, @m11,
		@m12, @m13, @m14, @m15
	)

	add: (rhs) => Matrix(
		 @m0 +  rhs.m0,  @m1 +  rhs.m1,  @m2 +  rhs.m2,  @m3 +  rhs.m3,
		 @m4 +  rhs.m4,  @m5 +  rhs.m5,  @m6 +  rhs.m6,  @m7 +  rhs.m7,
		 @m8 +  rhs.m8,  @m9 +  rhs.m9, @m10 + rhs.m10, @m11 + rhs.m11,
		@m12 + rhs.m12, @m13 + rhs.m13, @m14 + rhs.m14, @m15 + rhs.m15
	)

	subtract: (rhs) => Matrix(
		 @m0 -  rhs.m0,  @m1 -  rhs.m1,  @m2 -  rhs.m2,  @m3 -  rhs.m3,
		 @m4 -  rhs.m4,  @m5 -  rhs.m5,  @m6 -  rhs.m6,  @m7 -  rhs.m7,
		 @m8 -  rhs.m8,  @m9 -  rhs.m9, @m10 - rhs.m10, @m11 - rhs.m11,
		@m12 - rhs.m12, @m13 - rhs.m13, @m14 - rhs.m14, @m15 - rhs.m15
	)

	multiply: (rhs) => Matrix(
		 @m0 * rhs.m0 +  @m1 * rhs.m4 +  @m2 *  rhs.m8 +  @m3 * rhs.m12,
		 @m0 * rhs.m1 +  @m1 * rhs.m5 +  @m2 *  rhs.m9 +  @m3 * rhs.m13,
		 @m0 * rhs.m2 +  @m1 * rhs.m6 +  @m2 * rhs.m10 +  @m3 * rhs.m14,
		 @m0 * rhs.m3 +  @m1 * rhs.m7 +  @m2 * rhs.m11 +  @m3 * rhs.m15,
		 @m4 * rhs.m0 +  @m5 * rhs.m4 +  @m6 *  rhs.m8 +  @m7 * rhs.m12,
		 @m4 * rhs.m1 +  @m5 * rhs.m5 +  @m6 *  rhs.m9 +  @m7 * rhs.m13,
		 @m4 * rhs.m2 +  @m5 * rhs.m6 +  @m6 * rhs.m10 +  @m7 * rhs.m14,
		 @m4 * rhs.m3 +  @m5 * rhs.m7 +  @m6 * rhs.m11 +  @m7 * rhs.m15,
		 @m8 * rhs.m0 +  @m9 * rhs.m4 + @m10 *  rhs.m8 + @m11 * rhs.m12,
		 @m8 * rhs.m1 +  @m9 * rhs.m5 + @m10 *  rhs.m9 + @m11 * rhs.m13,
		 @m8 * rhs.m2 +  @m9 * rhs.m6 + @m10 * rhs.m10 + @m11 * rhs.m14,
		 @m8 * rhs.m3 +  @m9 * rhs.m7 + @m10 * rhs.m11 + @m11 * rhs.m15,
		@m12 * rhs.m0 + @m13 * rhs.m4 + @m14 *  rhs.m8 + @m15 * rhs.m12,
		@m12 * rhs.m1 + @m13 * rhs.m5 + @m14 *  rhs.m9 + @m15 * rhs.m13,
		@m12 * rhs.m2 + @m13 * rhs.m6 + @m14 * rhs.m10 + @m15 * rhs.m14,
		@m12 * rhs.m3 + @m13 * rhs.m7 + @m14 * rhs.m11 + @m15 * rhs.m15
	)

	determinant: =>
		@m12 * @m9 *  @m6 *  @m3 - @m8 * @m13 *  @m6 *  @m3 - @m12 * @m5 * @m10 *  @m3 + @m4 * @m13 * @m10 *  @m3 +
		 @m8 * @m5 * @m14 *  @m3 - @m4 *  @m9 * @m14 *  @m3 - @m12 * @m9 *  @m2 *  @m7 + @m8 * @m13 *  @m2 *  @m7 +
		@m12 * @m1 * @m10 *  @m7 - @m0 * @m13 * @m10 *  @m7 -  @m8 * @m1 * @m14 *  @m7 + @m0 *  @m9 * @m14 *  @m7 +
		@m12 * @m5 *  @m2 * @m11 - @m4 * @m13 *  @m2 * @m11 - @m12 * @m1 *  @m6 * @m11 + @m0 * @m13 *  @m6 * @m11 +
		 @m4 * @m1 * @m14 * @m11 - @m0 *  @m5 * @m14 * @m11 -  @m8 * @m5 *  @m2 * @m15 + @m4 *  @m9 *  @m2 * @m15 +
		 @m8 * @m1 *  @m6 * @m15 - @m0 *  @m9 *  @m6 * @m15 -  @m4 * @m1 * @m10 * @m15 + @m0 *  @m5 * @m10 * @m15

	trace: => @m0 + @m5 + @m10 + @m15

	transpose: => Matrix(
		@m0, @m4,  @m8, @m12,
		@m1, @m5,  @m9, @m13,
		@m2, @m6, @m10, @m14,
		@m3, @m7, @m11, @m15
	)

	invert: =>
		b00 =  @m0 *  @m5 -  @m1 *  @m4
		b01 =  @m0 *  @m6 -  @m2 *  @m4
		b02 =  @m0 *  @m7 -  @m3 *  @m4
		b03 =  @m1 *  @m6 -  @m2 *  @m5
		b04 =  @m1 *  @m7 -  @m3 *  @m5
		b05 =  @m2 *  @m7 -  @m3 *  @m6
		b06 =  @m8 * @m13 -  @m9 * @m12
		b07 =  @m8 * @m14 - @m10 * @m12
		b08 =  @m8 * @m15 - @m11 * @m12
		b09 =  @m9 * @m14 - @m10 * @m13
		b10 =  @m9 * @m15 - @m11 * @m13
		b11 = @m10 * @m15 - @m11 * @m14

		invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06)

		Matrix(
			(  @m5 * b11 -  @m6 * b10 +  @m7 * b09) * invDet,
			( -@m1 * b11 +  @m2 * b10 -  @m3 * b09) * invDet,
			( @m13 * b05 - @m14 * b04 + @m15 * b03) * invDet,
			( -@m9 * b05 + @m10 * b04 - @m11 * b03) * invDet,
			( -@m4 * b11 +  @m6 * b08 -  @m7 * b07) * invDet,
			(  @m0 * b11 -  @m2 * b08 +  @m3 * b07) * invDet,
			(-@m12 * b05 + @m14 * b02 - @m15 * b01) * invDet,
			(  @m8 * b05 - @m10 * b02 + @m11 * b01) * invDet,
			(  @m4 * b10 -  @m5 * b08 +  @m7 * b06) * invDet,
			( -@m0 * b10 +  @m1 * b08 -  @m3 * b06) * invDet,
			( @m12 * b04 - @m13 * b02 + @m15 * b00) * invDet,
			( -@m8 * b04 +  @m9 * b02 - @m11 * b00) * invDet,
			( -@m4 * b09 +  @m5 * b07 -  @m6 * b06) * invDet,
			(  @m0 * b09 -  @m1 * b07 +  @m2 * b06) * invDet,
			(-@m12 * b03 + @m13 * b01 - @m14 * b00) * invDet,
			(  @m8 * b03 -  @m9 * b01 + @m10 * b00) * invDet
		)

	normalize: =>
		det = @m12 * @m9 *  @m6 * @m3 -  @m8 * @m13 *  @m6 *  @m3 - @m12 * @m5 * @m10 *  @m3 + @m4 * @m13 * @m10 *  @m3 +
			   @m8 * @m5 * @m14 *  @m3 - @m4 *  @m9 * @m14 *  @m3 - @m12 * @m9 *  @m2 *  @m7 + @m8 * @m13 *  @m2 *  @m7 +
			  @m12 * @m1 * @m10 *  @m7 - @m0 * @m13 * @m10 *  @m7 -  @m8 * @m1 * @m14 *  @m7 + @m0 *  @m9 * @m14 *  @m7 +
			  @m12 * @m5 *  @m2 * @m11 - @m4 * @m13 *  @m2 * @m11 - @m12 * @m1 *  @m6 * @m11 + @m0 * @m13 *  @m6 * @m11 +
			   @m4 * @m1 * @m14 * @m11 - @m0 *  @m5 * @m14 * @m11 -  @m8 * @m5 *  @m2 * @m15 + @m4 *  @m9 *  @m2 * @m15 +
			   @m8 * @m1 *  @m6 * @m15 - @m0 *  @m9 *  @m6 * @m15 -  @m4 * @m1 * @m10 * @m15 + @m0 *  @m5 * @m10 * @m15

		Matrix(
			 @m0 / det,  @m1 / det,  @m2 / det,  @m3 / det,
			 @m4 / det,  @m5 / det,  @m6 / det,  @m7 / det,
			 @m8 / det,  @m9 / det, @m10 / det, @m11 / det,
			@m12 / det, @m13 / det, @m14 / det, @m15 / det
		)

	toFloatV: =>
		ffi.new('float[16]', @m0, @m1, @m2, @m3, @m4, @m5, @m6, @m7, @m8, @m9, @m10, @m11, @m12, @m13, @m14, @m15)
}

MatrixMT.__index = MatrixMT

ffi.metatype(Matrix, MatrixMT)
